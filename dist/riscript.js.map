{"version":3,"sources":["../src/riscript.js","../src/tokens.js","../src/parser.js","../src/visitor.js","../src/grammar.js","../src/index.js"],"sourcesContent":["import he from 'he';\nimport { Query } from 'mingo';\nimport { Lexer } from 'chevrotain';\n\nimport { getTokens } from './tokens.js';\nimport { RiScriptParser } from './parser.js';\nimport { RiScriptVisitor } from './visitor.js';\n\n/*\n  Specification:\n    script: expr+\n    expr: (atom)+\n    wexpr: (atom)+ weight\n    symbol: SYM transform*\n    assign: SYM EQ expr transform*\n    gate: @mingo@\n    silent: { gate? expr }\n    atom: (choice | symbol | text | silent) weight?\n    choice: [ gate? ( expr | wexpr ) (OR  (expr | wexpr ) )* else? ] transform*\n    else: ELSE expr\n    raw: Raw\n*/\n\nconst { decode } = he;\nconst VowelRE = /[aeiou]/;\nconst RegexEscape = '_RE_';\nconst HtmlEntities = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;\n\nclass RiQuery extends Query {\n  constructor(scripting, condition, options) {\n    if (typeof condition === 'string') {\n      let raw = condition; // eslint-disable-line\n      condition = scripting.parseJSOL(condition);\n      // console.log('RAW: ', raw, 'parsed', condition);\n    }\n    super(condition, options);\n  }\n\n  test(obj) {\n    for (let i = 0, len = this.compiled.length; i < len; i++) {\n      if (!this.compiled[i](obj)) return false;\n    }\n    return true;\n  }\n\n  operands() {\n    const stack = [this.condition];\n    const keys = new Set();\n    while (stack?.length > 0) {\n      const currentObj = stack.pop();\n      Object.keys(currentObj).forEach((key) => {\n        const value = currentObj[key];\n        // console.log(`key: ${ key }, value: ${ value } `);\n        if (!key.startsWith('$')) keys.add(key);\n        if (typeof value === 'object' && value !== null) {\n          const eles = Array.isArray(value) ? value : [value];\n          eles.forEach((ele) => stack.push(ele));\n        }\n      });\n    }\n    return Array.from(keys);\n  }\n}\n\nclass RiScript {\n  static Query = RiQuery;\n\n  static VERSION = '1.0.19';\n  static RiTaWarnings = { plurals: false, phones: false };\n\n  static evaluate(script, context, opts = {}) {\n    return new RiScript().evaluate(script, context, opts);\n  }\n\n  constructor(opts = {}) { // private ?\n    this.visitor = 0; // created in evaluate() or passed in here\n    this.v2Compatible = opts.compatibility === 2;\n    const { Constants, tokens } = getTokens(this.v2Compatible);\n    this.Escaped = Constants.Escaped;\n    this.Symbols = Constants.Symbols;\n\n    const anysym = Constants.Escaped.STATIC + Constants.Escaped.DYNAMIC;\n    const open = Constants.Escaped.OPEN_CHOICE;\n    const close = Constants.Escaped.CLOSE_CHOICE;\n\n    this.JSOLIdentRE = new RegExp(`([${anysym}]?[A-Za-z_0-9][A-Za-z_0-9]*)\\\\s*:`, 'g');\n    this.RawAssignRE = new RegExp(`^[${anysym}][A-Za-z_0-9][A-Za-z_0-9]*\\\\s*=`);\n    this.ChoiceWrapRE = new RegExp('^' + open + '[^' + open + close + ']*' + close + '$');\n\n    this.SpecialRE = new RegExp(`[${this.Escaped.SPECIAL.replace('&', '')}]`);\n    this.ContinueRE = new RegExp(this.Escaped.CONTINUATION + '\\\\r?\\\\n', 'g');\n    this.WhitespaceRE = /[\\u00a0\\u2000-\\u200b\\u2028-\\u2029\\u3000]+/g;\n    this.AnySymbolRE = new RegExp(`[${anysym}]`); // added\n\n    this.silent = false;\n    this.lexer = new Lexer(tokens);\n    this.parser = new RiScriptParser(tokens);\n    this.RiTa = opts.RiTa || {\n      VERSION: 0,\n      randi: (k) => Math.floor(Math.random() * k),\n    }\n  }\n\n  lex(opts) {\n    if (!opts.input) throw Error('no input');\n    const lexResult = this.lexer.tokenize(opts.input);\n    if (lexResult.errors.length) {\n      console.error('Input: ' + opts.input + '\\n', lexResult.errors[0].message);\n      throw Error('[LEXING] ' + lexResult.errors[0].message);\n    }\n    if (opts.trace) this.printTokens(lexResult.tokens);\n    opts.tokens = lexResult.tokens;\n    // return lexResult;\n  }\n\n  parse(opts) {\n    opts.cst = this.parser.parse(opts);\n  }\n\n  visit(opts) {\n    return this.visitor.start(opts);\n  }\n\n  lexParseVisit(opts = {}) {\n    this.lex(opts);\n    this.parse(opts);\n    return this.visit(opts);\n  }\n\n  evaluate(script, context, opts = {}) {\n    if (typeof script !== 'string') {\n      throw Error('RiScript.evaluate() expects a string, got ' + typeof script);\n    }\n    opts.input = script;\n    opts.visitor = new RiScriptVisitor(this, context);\n    return this._evaluate(opts);\n  }\n\n  _evaluate(opts) {\n    const { input } = opts;\n\n    // opts.onepass = true; // TMP\n\n    let last, endingBreak = /\\r?\\n$/.test(input); // keep\n\n    let expr = this.preParse(input, opts);\n    if (!expr) return '';\n\n    if (opts.trace) console.log(`\\nInput:  '${RiScript._escapeText(input)}'`);\n    if (opts.trace && input !== expr) {\n      console.log(`Parsed: '${RiScript._escapeText(expr)}'`);\n    }\n\n    if (!opts.visitor) throw Error('no visitor');\n    this.visitor = opts.visitor;\n    delete opts.visitor; // remind me why\n\n    for (let i = 1; expr !== last && i <= 10; i++) {\n      last = expr;\n\n      if (opts.trace) console.log('-'.repeat(20) + ' Pass#' + i + ' ' + '-'.repeat(20));\n\n      opts.input = expr;\n      expr = this.lexParseVisit(opts); // do it\n\n      if (opts.trace) {\n        console.log(`Result(${i}) -> \"` + `${RiScript._escapeText(expr)}\"`\n          + ` ctx=${this.visitor.lookupsToString()}`);\n      }\n\n      // end if no more riscript\n      if (opts.onepass || !this.isParseable(expr)) break;\n    }\n\n    // check for unresolved symbols ([$#]) after removing HTML entities\n    if (!this.silent && !this.RiTa.SILENT) {\n      if (this.AnySymbolRE.test(expr.replace(HtmlEntities, ''))) {\n        console.warn('[WARN] Unresolved symbol(s) in \"' + expr.replace(/\\n/g, '\\\\n') + '\" ');\n      }\n    }\n\n    return this.postParse(expr, opts) + (endingBreak ? '\\n' : '');\n  }\n\n  _query(rawQuery, opts) {\n    return new RiQuery(this, rawQuery, opts);\n  }\n\n  printTokens(tokens) {\n    let s = tokens.reduce((str, t) => {\n      let { name } = t.tokenType;\n      let tag = name;\n      if (tag === 'TEXT') tag = RiScript._escapeText(t.image, 1);\n      if (tag === 'SYM') tag = 'sym(' + t.image + ')';\n      if (tag === 'TX') tag = 'tx(' + t.image + ')';\n      return str + tag + ', ';\n    }, '')\n      .slice(0, -2);\n    console.log('\\nTokens: [ ' + s + ' ]  Context:',\n      this.visitor.lookupsToString());\n  }\n\n  postParse(input, opts) {\n    if (typeof input !== 'string') return '';\n\n    // replace html entities\n    let decoded = decode(input);\n\n    // clean up whitespace, linebreaks\n    let result = decoded.replace(this.WhitespaceRE, ' ').replace(/\\r?\\n$/, '');\n\n    // handle unresolved gates\n    let gates = [...result.matchAll(this.Symbols.PENDING_GATE_RE)];\n    gates.forEach((g) => {\n      if (!g || !g[0] || !g[1]) throw Error('bad gate: ' + g);\n      let deferredGate = this.visitor.pendingGates[g[1]];\n      let { deferredContext, operands } = deferredGate;\n      if (!operands.length) throw Error('no operands');\n      let reject = this.visitor.choice(deferredContext, { forceReject: true });\n\n      result = result.replace(g[0], reject);\n      if (opts.trace) console.log('  ' + g[0] + '-> ' + reject);\n    });\n\n    if (opts.trace) console.log(`\\nFinal: '${result}'`);\n\n    if (!opts.preserveLookups) {\n      // reset lookups unless preserveLookups=true (for testing only)\n      this.visitor.statics = undefined;\n      this.visitor.dynamics = undefined;\n    }\n\n    return result;\n  }\n\n  preParse(script, opts) {\n    if (typeof script !== 'string') return '';\n\n    const $ = this.Symbols;\n\n    let input = script;\n    if (!this.v2Compatible) {\n      // handle parenthesized weights ??\n      input = input.replace(/\\((\\s*\\d+\\s*)\\)/g, '^$1^');\n    }\n\n    input = input.replace(/\\/\\*[^]*?(\\r?\\n)?\\//g, ''); // multi-line comments\n    input = input.replace(/\\/\\/[^\\n]+(\\r?\\n|$)/g, ''); // single-line comments\n    input = input.replace(this.ContinueRE, ''); // line continuations\n    input = slashEscapesToEntities(input); // double-backslashed escapes\n\n    let result = '';\n    let lines = input.split(/\\r?\\n/);\n    for (let i = 0; i < lines.length; i++) {\n      // special-case: handle assignments alone on a line\n      if (/*!opts.noAddedSilence && */ this.RawAssignRE.test(lines[i])) {\n        // a very convoluted way of preserving line-breaks inside groups\n        let eqIdx = lines[i].indexOf('=');\n        if (eqIdx < 0) throw Error('invalid state: no assigment: ' + lines[i]);\n        let lhs = lines[i].substring(0, eqIdx),\n          rhs = lines[i].substring(eqIdx + 1);\n        let opens = charCount(rhs, $.OPEN_CHOICE);\n        let closes = charCount(rhs, $.CLOSE_CHOICE);\n        while (opens > closes) {\n          let line = lines[++i];\n          rhs += '\\n' + line;\n          opens += charCount(line, $.OPEN_CHOICE);\n          closes += charCount(line, $.CLOSE_CHOICE);\n        }\n        result += $.OPEN_SILENT + (lhs + '=' + rhs) + $.CLOSE_SILENT;\n      } else {\n        result += lines[i];\n        if (i < lines.length - 1) result += '\\n';\n      }\n    }\n\n    return result;\n  }\n\n  /*\n   * Parses a mingo query into JSON format\n   */\n  parseJSOL(text) {\n    const unescapeRegexProperty = (text) => {\n      // TODO: why do we need this?\n      let res = text;\n      if (\n        typeof text === 'string' &&\n        text.startsWith(RegexEscape) &&\n        text.endsWith(RegexEscape)\n      ) {\n        let parts = text.split(RegexEscape);\n        if (parts.length !== 4) throw Error('invalid regex in unescape');\n        res = new RegExp(parts[1], parts[2]);\n      }\n      return res;\n    };\n    let escaped = RiScript._escapeJSONRegex(text)\n      .replace(this.JSOLIdentRE, '\"$1\":')\n      .replace(/'/g, '\"');\n\n    // console.log(\"escaped: '\"+escaped+\"'\");\n\n    let result = JSON.parse(escaped),\n      urp = unescapeRegexProperty;\n    Object.keys(result).forEach((k) => (result[k] = urp(result[k])));\n    return result;\n  }\n\n  isParseable(s) {\n    // conservatively assume non-string/numbers are always parseable\n    let result = true;\n    let isStrOrNum = /(string|number)/.test(typeof s);\n    // if a string or num, test for special chars\n    if (isStrOrNum) result = this.SpecialRE.test(s.toString());\n    return result;\n  }\n\n  // ========================= statics ===============================\n\n\n  // Default transform that adds an article\n  static articlize(s) {\n    if (!s || !s.length) return '';\n\n    let first = s.split(/\\s+/)[0];\n\n    if (!RiScript.RiTa?.phones) {\n      if (!RiScript.RiTaWarnings.phones) {\n        console.warn('[WARN] Install RiTa for proper phonemes');\n        RiScript.RiTaWarnings.phones = true;\n      }\n      // first.startsWith('a') ? 'an ' : 'a ') + s;\n      return (/^[aeiou].*/i.test(first) ? 'an ' : 'a ') + s;\n    }\n\n    let phones = RiScript.RiTa.phones(first, { silent: true });\n\n    // could still be original word if no phones found\n    return (\n      (phones && phones.length && VowelRE.test(phones[0]) ? 'an ' : 'a ') + s\n    );\n  }\n\n  // Default transform that capitalizes the first character\n  static capitalize(s) {\n    return s ? s[0].toUpperCase() + s.substring(1) : '';\n  }\n\n  // Default transform that capitalizes the string\n  static uppercase(s) {\n    return s ? s.toUpperCase() : '';\n  }\n\n  // Default transform that wraps the string in (smart) quotes.\n  static quotify(s) {\n    return '&#8220;' + (s || '') + '&#8221;';\n  }\n\n  // Default transform that pluralizes a string (requires RiTa)\n  static pluralize(s) {\n    if (!RiScript.RiTa?.pluralize) {\n      if (!RiScript.RiTaWarnings.plurals) {\n        RiScript.RiTaWarnings.plurals = true;\n        console.warn('[WARN] Install RiTa for proper pluralization');\n      }\n      return s.endsWith('s') ? s : s + 's';\n    }\n    return RiScript.RiTa.pluralize(s);\n  }\n\n  // Default no-op transform\n  static identity(s) {\n    return s;\n  }\n\n  // static helpers\n\n  static _transformNames(txs) {\n    return txs && txs.length\n      ? txs.map((tx) => tx.image.replace(/(^\\.|\\(\\)$)/g, ''), [])\n      : [];\n  }\n\n  static _escapeText(s, quotify) {\n    if (typeof s !== 'string') return s;\n    let t = s.replace(/\\r?\\n/g, '\\\\n');\n    return quotify || !t.length ? \"'\" + t + \"'\" : t;\n  }\n\n  static _escapeJSONRegex(text) {\n    return text.replace(\n      /\\/([^/]+?)\\/([igmsuy]*)/g,\n      `\"${RegexEscape}$1${RegexEscape}$2${RegexEscape}\"`\n    );\n  }\n\n  static _stringHash(s) {\n    let chr,\n      hash = 0;\n    for (let i = 0; i < s.length; i++) {\n      chr = s.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n    let strHash = hash.toString();\n    return hash < 0 ? strHash.replace('-', '0') : strHash;\n  }\n}\n\n////////////////////// STATIC PROPS ///////////////////////\n\nRiScript.transforms = {\n  quotify: RiScript.quotify,\n  pluralize: RiScript.pluralize,\n  capitalize: RiScript.capitalize,\n  articlize: RiScript.articlize,\n  uppercase: RiScript.uppercase,\n\n  // sequences\n  norepeat: RiScript.identity,\n\n  // aliases\n  art: RiScript.articlize,\n  nr: RiScript.identity,\n  cap: RiScript.capitalize,\n  ucf: RiScript.capitalize, // deprecated?\n  uc: RiScript.uppercase,\n  qq: RiScript.quotify,\n  s: RiScript.pluralize,\n};\n\n///////////////////////// FUNCTIONS /////////////////////////\n\nfunction slashEscapesToEntities(s) {\n  s = replaceAll(s, '\\\\(', '&lpar;');\n  s = replaceAll(s, '\\\\)', '&rpar;');\n  s = replaceAll(s, '\\\\[', '&lsqb;');\n  s = replaceAll(s, '\\\\]', '&rsqb;');\n  s = replaceAll(s, '\\\\{', '&lcqb;');\n  s = replaceAll(s, '\\\\}', '&rcqb;');\n  s = replaceAll(s, '\\\\@', '&commat;');\n  s = replaceAll(s, '\\\\#', '&num;');\n  s = replaceAll(s, '\\\\|', ' &vert');\n  s = replaceAll(s, '\\\\=', ' &equals');\n  return s;\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction replaceAll(str, match, replacement) {\n  return str.replace(new RegExp(escapeRegExp(match), 'g'), () => replacement);\n}\nfunction charCount(str, c) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === c) count++;\n  }\n  return count;\n}\n\nexport { RiScript };","import { createToken } from \"chevrotain\"\n\nfunction getTokens(v2Compatible) {\n\n  let Symbols = {\n    OR: '|',\n    ELSE: '||',\n    DYNAMIC: '$',\n    STATIC: '#',\n    ENTITY: '&',\n    OPEN_GATE: '@',\n    CLOSE_GATE: '@',\n    PENDING_GATE: '@@',\n    OPEN_SILENT: '{',\n    CLOSE_SILENT: '}',\n  };\n\n  let v2Symbols = {\n    OPEN_CHOICE: '(',\n    CLOSE_CHOICE: ')',\n    OPEN_WEIGHT: '[',\n    CLOSE_WEIGHT: ']',\n    CONTINUATION: '\\\\',\n  };\n\n  let v3Symbols = {\n    OPEN_CHOICE: '[',\n    CLOSE_CHOICE: ']',\n    OPEN_WEIGHT: '^', // also allows (int), eg. (3)\n    CLOSE_WEIGHT: '^',\n    CONTINUATION: '~',\n  };\n\n  Object.assign(Symbols, v2Compatible ? v2Symbols : v3Symbols);\n\n  const Escaped = {};\n  Object.entries(Symbols).forEach(([k, v]) => { Escaped[k] = escapeRegex(v) });\n\n  const PENDING_GATE_PATTERN = new RegExp(`${Escaped.PENDING_GATE}([0-9]{9,11})`)\n\n  Escaped.SPECIAL = Object.values(Escaped).join('').replace(/[<>]/g, ''); // allow <>& for html \n  Symbols.PENDING_GATE_RE = new RegExp(PENDING_GATE_PATTERN.source, 'g'); // for unresolved gates\n\n  const ExitGate = createToken({\n    name: \"ExitGate\",\n    pattern: new RegExp(`\\\\s*${Escaped.CLOSE_GATE}`),\n    pop_mode: true\n  });\n\n  const Gate = createToken({\n    name: \"Gate\",\n    pattern: new RegExp(`[^${Escaped.CLOSE_GATE}]+`)\n  });\n\n  const PendingGate = createToken({\n    name: \"PendingGate\",\n    pattern: PENDING_GATE_PATTERN\n  });\n\n  const EnterGate = createToken({\n    name: \"EnterGate\",\n    pattern: new RegExp(`${Escaped.OPEN_GATE}\\\\s*`),\n    push_mode: \"gate_mode\"\n  });\n\n  \n  const OC = createToken({ name: \"OC\", pattern: new RegExp(Escaped.OPEN_CHOICE + '\\\\s*') });\n  const CC = createToken({ name: \"CC\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_CHOICE}`) });\n  const OR = createToken({ name: \"OR\", pattern: /\\s*\\|\\s*/ });\n  const ELSE = createToken({ name: \"ELSE\", pattern: /\\s*\\|\\|\\s*/ });\n  const EQ = createToken({ name: \"EQ\", pattern: /\\s*=\\s*/ });\n  const TF = createToken({ name: \"TF\", pattern: /\\.[A-Za-z_0-9][A-Za-z_0-9]*(\\(\\))?/ });\n  const OS = createToken({ name: \"OS\", pattern: new RegExp(`${Escaped.OPEN_SILENT}\\\\s*`) });\n  const CS = createToken({ name: \"CS\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_SILENT}`) });\n  const SYM = createToken({ name: \"SYM\", pattern: new RegExp(`[${Escaped.DYNAMIC}${Escaped.STATIC}][A-Za-z_0-9]*`) });\n\n  const Entity = createToken({ name: \"Entity\", pattern: /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/i });\n  const Weight = createToken({ name: \"Weight\", pattern: new RegExp(`\\\\s*${Escaped.OPEN_WEIGHT}.+${Escaped.CLOSE_WEIGHT}\\\\s*`) });\n  const Raw = createToken({ name: \"Raw\", pattern: new RegExp(`[^${Escaped.SPECIAL}]+`) });\n\n  const normalMode = [Entity, Weight, ELSE, OC, CC, OR, EQ, SYM, TF, OS, CS, PendingGate, Raw, EnterGate];\n  const gateMode = [Gate, ExitGate];\n\n  const multiMode = {\n    modes: {\n      normal: normalMode,\n      gate_mode: gateMode\n    },\n    defaultMode: 'normal'\n  };\n\n  return { tokens: multiMode, Constants: { Symbols, Escaped } };\n}\n\nfunction escapeRegex(s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\n// console.log(getTokens().tokens.modes.normal.map(t => t.name));\n\nexport { getTokens };","\nimport { CstParser } from \"chevrotain\"\n\nclass RiScriptParser extends CstParser {\n\n  constructor(allTokens) {\n    super(allTokens, { nodeLocationTracking: \"full\" });\n    this.atomTypes = ['silent', 'assign', 'symbol', 'choice', 'pgate', 'text', 'entity'];\n    this.buildRules();\n  }\n\n  parse(opts) {\n    this.input = opts.tokens; // superclass member (do not change)\n    \n    let cst = this.script();\n    if (this.errors.length > 0) throw Error\n      (\"[PARSING]\\n\" + this.errors[0].message);\n    return cst;\n  }\n\n  buildRules() {\n\n    const $ = this, Tokens = this.tokensMap;\n\n    $.RULE(\"script\", () => {\n      $.MANY(() => $.SUBRULE($.expr));\n    });\n\n    $.RULE(\"pgate\", () => {\n      $.CONSUME(Tokens.PendingGate);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"entity\", () => {\n      $.CONSUME(Tokens.Entity);\n    });\n\n    $.RULE(\"gate\", () => {\n      $.CONSUME(Tokens.EnterGate);\n      $.MANY(() => $.CONSUME(Tokens.Gate));\n      $.CONSUME(Tokens.ExitGate);\n    });\n\n    $.RULE(\"silent\", () => {\n      $.CONSUME(Tokens.OS);\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.CONSUME(Tokens.SYM);\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.EQ);\n        $.SUBRULE($.expr);\n      });\n      $.CONSUME(Tokens.CS);\n    });\n\n    $.RULE(\"assign\", () => {\n      $.CONSUME(Tokens.SYM);\n      $.CONSUME(Tokens.EQ);\n      $.SUBRULE($.expr);\n    });\n\n    $.RULE(\"symbol\", () => {\n      $.CONSUME(Tokens.SYM);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"accept\", () => {\n      $.SUBRULE($.or_expr);\n    });\n\n    $.RULE(\"reject\", () => {\n      $.SUBRULE($.or_expr);\n    });\n\n    $.RULE(\"or_expr\", () => {\n      $.MANY_SEP({\n        SEP: Tokens.OR,\n        DEF: () => $.SUBRULE($.wexpr)\n      });\n    });\n\n    // choice: (LP (wexpr OR)* wexpr RP) transform*;\n    $.RULE(\"choice\", () => {\n      $.CONSUME(Tokens.OC)\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.SUBRULE($.accept)\n      // $.MANY_SEP({\n      //   SEP: Tokens.OR,\n      //   DEF: () => $.SUBRULE($.wexpr)\n      // });\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.ELSE);\n        $.SUBRULE($.reject)\n      });\n      $.CONSUME(Tokens.CC);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"wexpr\", () => {\n      $.MANY(() => {\n        $.OR([\n          { ALT: () => $.SUBRULE($.expr) },\n          { ALT: () => $.CONSUME(Tokens.Weight) },\n        ])\n      });\n    });\n\n    $.RULE(\"expr\", () => {\n      $.AT_LEAST_ONE(() => $.SUBRULE($.atom));\n    });\n\n    $.RULE(\"atom\", () => {\n      $.OR(this.atomTypes.map(t => ({ ALT: () => $.SUBRULE($[t]) })));\n    });\n\n    $.RULE(\"text\", () => {\n      $.CONSUME(Tokens.Raw);\n    });\n\n    this.performSelfAnalysis(); // keep\n  }\n}\n\nexport { RiScriptParser };","\nclass BaseVisitor {\n  constructor(riScript) {\n    this.input = 0;\n\n    this.path = '';\n    this.tracePath = true;\n    this.scripting = riScript;\n    this.warnOnInvalidGates = false;\n    this.RiScript = this.scripting.constructor; // class hack\n  }\n\n  isCstNode(o) {\n    return (typeof o === 'object' &&\n      ('accept' in o || ('name' in o && 'location' in o && 'children' in o)));\n  }\n\n  visit(cstNode, param) {\n    if (Array.isArray(cstNode)) {\n      cstNode = cstNode[0];\n    }\n    if (typeof cstNode === 'undefined') {\n      return undefined;\n    }\n    if (!this.isCstNode(cstNode)) {\n      throw Error('Non-cstNode passed to visit: ' + JSON.stringify(cstNode));\n    }\n\n    const { name, location } = cstNode;\n\n    this.nodeText = this.input.substring(\n      location.startOffset,\n      location.endOffset + 1\n    );\n\n    if (typeof this[name] !== 'function') {\n      throw Error('BaseVisitor.visit: expecting function for this[' +\n        `${name}], found ${typeof this[name]}: ${JSON.stringify(this[name])}`);\n    }\n\n    if (this.tracePath && !/(expr|atom|silent)/.test(name)) {\n      this.path += name + '.';\n    }\n    return this[name](cstNode.children, param);\n  }\n\n  validateVisitor() {\n    /* no-op */\n  }\n}\n\nclass RiScriptVisitor extends BaseVisitor {\n  constructor(riScript, context = {}) {\n    super(riScript); // stored as global RiScript (TODO)\n    this.context = context;\n\n    this.trace = 0;\n    this.choices = {};\n    this.isNoRepeat = false;\n    this.symbols = this.scripting.Symbols;\n    this.escaped = this.scripting.Escaped;\n\n    // lookups\n    this.statics = {};\n    this.dynamics = {};\n    this.pendingGates = {};\n    this.pendingSymbols = new Set();\n\n    this.validateVisitor(); // keep\n  }\n\n  start(opts = {}) {\n    this.input = opts.input;\n    this.trace = opts.trace;\n    this.traceTx = opts.traceTx;\n    if (!opts.cst) throw Error('no cst');\n    return super.visit(opts.cst);\n  }\n\n  script(ctx) {\n    this.order = 0;\n    const count = ctx.expr ? ctx.expr.length : 0;\n    this.print('script', \"'\" + this.RiScript._escapeText(this.input)\n      + \"' :: \" + count + ' expression(s)');\n    if (!count) return '';\n    if (Object.keys(ctx).length !== 1) throw Error('script: invalid expr');\n    return this.visit(ctx.expr);\n  }\n\n  expr(ctx) {\n    // this.print('expr', ctx);\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid expr: ' + types.length);\n    const exprs = ctx.atom.map((c) => this.visit(c));\n    // handle special cases of the form: \"not [quite|] far enough\"\n    for (let i = 1; i < exprs.length - 1; i++) {\n      if (\n        exprs[i].length === 0 &&\n        exprs[i - 1].endsWith(' ') &&\n        exprs[i + 1].startsWith(' ')\n      ) {\n        exprs[i + 1] = exprs[i + 1].substring(1);\n      }\n    }\n    return exprs.join('');\n  }\n\n  wexpr(ctx) {\n    this.print('wexpr');\n  }\n\n  gate(ctx) {\n    // returns { decision: [accept | reject] } or { decision: 'defer', operands: [] }\n\n    if (ctx.Gate.length !== 1) throw Error('Invalid gate: ' + ctx.Gate);\n\n    let mingoQuery;\n    const raw = ctx.Gate[0].image;\n    try {\n      mingoQuery = this.scripting._query(raw);\n    } catch (e) {\n      if (!this.warnOnInvalidGates) {\n        throw Error(`Invalid gate[2]: \"@${raw}@\"\\n\\nRootCause -> ${e}`);\n      }\n      if (!this.scripting.RiTa.SILENT && !this.scripting.silent) {\n        console.warn(`[WARN] Ignoring invalid gate: @${raw}@\\n`, e);\n      }\n      return { decision: 'accept' };\n    }\n\n    const resolvedOps = {};\n    const unresolvedOps = [];\n    const operands = mingoQuery.operands();\n    operands.forEach((sym) => {\n      let { result, resolved, isStatic, isUser } = this.checkContext(sym);\n\n      if (typeof result === 'function') {\n        // while {} ?\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n      }\n      if (typeof result === 'undefined' || !resolved) {\n        unresolvedOps.push(sym);\n      } else {\n        // add to appropriate context\n        if (isStatic) {\n          this.statics[sym] = result;\n        } else if (isUser) {\n          this.context[sym] = result;\n        } else {\n          this.dynamics[sym] = result;\n        }\n        // store resolved result\n        resolvedOps[sym] = result;\n      }\n    });\n\n    if (\n      Object.keys(resolvedOps).length + unresolvedOps.length !==\n      operands.length\n    ) { throw Error('invalid operands'); }\n\n    // if we have unresolved operands, return them (and defer)\n    if (unresolvedOps.length) { return { decision: 'defer', operands: unresolvedOps }; }\n\n    let result = mingoQuery.test(resolvedOps); // do test\n    if (!result && this.castValues(resolvedOps)) {\n      result = mingoQuery.test(resolvedOps); // redo test after casting\n    }\n\n    return { decision: result ? 'accept' : 'reject' };\n  }\n\n  assign(ctx, opts) {\n    const sym = ctx.SYM[0].image;\n    let value;\n    let info;\n    const ident = sym.replace(this.scripting.AnySymbolRE, '');\n    const isStatic = sym.startsWith(this.symbols.STATIC);\n\n    if (isStatic) {\n      value = this.visit(ctx.expr);\n      if (this.scripting.isParseable(value)) {\n        this.statics[ident] = value; // store in lookup table ??\n        value = this.inlineAssignment(ident, ctx.TF, value);\n      } else {\n        this.statics[ident] = value; // store in lookup table\n        this.pendingSymbols.delete(ident); // no longer pending\n        this.trace &&\n          console.log('  [pending.delete]', sym,\n            this.pendingSymbols.length\n              ? JSON.stringify(this.pendingSymbols)\n              : ''\n          );\n      }\n      info = `${sym} = ${this.RiScript._escapeText(value)}` +\n        ` [#static] ${opts?.silent ? '{silent}' : ''}`;\n    } else {\n      const $ = this;\n\n      // dynamic: store as func to be resolved later, perhaps many times\n      value = () => $.visit(ctx.expr);\n      info = `${sym} = <f*:pending>` + (opts?.silent ? '{silent}' : '');\n\n      // NOTE: this function may contain a choice, which needs to be handled\n      // when called from a symbol with a norepeat transform (??) TODO: test\n\n      this.dynamics[ident] = value; // store in lookup table\n    }\n    this.print('assign', info);\n\n    return value;\n  }\n\n  silent(ctx) {\n    if (ctx.EQ) {\n      this.assign(ctx, { silent: true });\n    } else {\n      this.symbol(ctx, { silent: true });\n    }\n    return '';\n  }\n\n  atom(ctx) {\n    let result;\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid atom: ' + types);\n    this.scripting.parser.atomTypes.forEach((type) => {\n      const context = ctx[type];\n      if (context) {\n        if (context.length !== 1) {\n          throw Error(type + ': bad length -> ' + ctx[type].length);\n        }\n        // console.log(type + ':', context[0]);\n        result = this.visit(context[0]);\n      }\n    });\n\n    // pending function, call it\n    if (typeof result === 'function') {\n      result = result.call();\n    }\n    return result;\n  }\n\n  text(ctx) {\n    if (ctx.Raw.length !== 1) throw Error('[1] invalid text');\n    if (Object.keys(ctx).length !== 1) throw Error('[2] invalid text');\n    const image = ctx.Raw[0].image;\n    this.print('text', this.RiScript._escapeText(\"'\" + image + \"'\"));\n    return image;\n  }\n\n  entity(ctx) {\n    return this.nodeText;\n  }\n\n  symbol(ctx, opts) {\n    if (ctx.SYM.length !== 1) throw Error('[1] invalid symbol');\n\n    const original = this.nodeText;\n    const symbol = ctx.SYM[0].image;\n    const ident = symbol.replace(this.scripting.AnySymbolRE, '');\n\n    this.isNoRepeat = this.hasNoRepeat(ctx.TF);\n\n    if (this.pendingSymbols.has(ident)) {\n      this.print('symbol', `${symbol} [is-pending]`);\n      return original;\n    }\n\n    // lookup: result is either a value, a function, or undef\n    let { result, isStatic, isUser, resolved } = this.checkContext(ident);\n\n    if (!isStatic && symbol.startsWith(this.symbols.STATIC)) {\n      if (!this.scripting.EntityRE.test(symbol)) {\n        throw Error(`Attempt to refer to dynamic symbol '${ident}' as` +\n          ` ${this.symbols.STATIC}${ident}, did you mean $${ident}?`);\n      }\n    }\n\n    if (typeof result === 'function') {\n      // while {} ?\n      result = result.call(); // call it\n      resolved = !this.scripting.isParseable(result);\n    }\n\n    if (this.isNoRepeat && (isStatic || isUser)) {\n      this.isNoRepeat = false;\n      const msg = 'Attempt to call norepeat() on ' + (isStatic\n        ? \"static symbol '\" + symbol + \"'. Did you mean to use '\" +\n        this.symbols.DYNAMIC + ident + \"' ?\"\n        : \"non-dynamic symbol '\" + ident + \"'. Did you mean to define '\" +\n        this.symbols.DYNAMIC + ident + \"' in riscript?\");\n      throw Error(msg);\n    }\n\n    if (typeof result === 'undefined') {\n      // nothing found, defer\n      this.print('symbol', symbol + \" -> '\" + original + \"' ctx=\" +\n        this.lookupsToString(), '[deferred]', opts?.silent ? '{silent}' : '');\n      return original;\n    }\n\n    let info = original + \" -> '\" + result + \"'\" + (opts?.silent ? ' {silent}' : '');\n\n    // defer if we still have unresolved riscript\n    if (typeof result === 'string' && !resolved) {\n      if (isStatic) {\n        this.pendingSymbols.add(ident);\n        result = this.inlineAssignment(ident, ctx.TF, result);\n        this.print('symbol*', `${original} -> ${result} :: pending.add(${ident})`);\n      } else {\n        if (ctx.TF) result = this.restoreTransforms(result, ctx.TF);\n        this.print('symbol', info);\n      }\n      return result;\n    }\n\n    if (isStatic) {\n      // store !untransformed! result in static context\n      this.statics[ident] = result; // ADDED 8/18/23 - FIXED 10/8/23\n    }\n\n    if (ctx.TF) {\n      result = this.applyTransforms(result, ctx.TF);\n      info += \" -> '\" + result + \"'\";\n      // info += \" -> \" + ctx.TF.map(tf => ` ${tf.image} -> `) + '\\'' + result + \"'\";\n      // console.log(\"INFO: \" + info);\n      if (this.isNoRepeat) info += ' (norepeat)';\n    }\n\n    this.print('symbol', info);\n\n    // resolved, so remove from pending\n    if (this.pendingSymbols.has(ident)) {\n      this.trace && console.log('  [$pending.delete]', (isStatic ? '#' : '$') + ident,\n        this.pendingSymbols.length ? JSON.stringify(this.pendingSymbols) : '');\n      this.pendingSymbols.delete(ident);\n    }\n    this.isNoRepeat = false; // reset\n\n    return result;\n  }\n\n  pgate(ctx) {\n    this.print('pgate', this.nodeText);\n    // new RegExp(`^${this.symbols.PENDING_GATE}`\n    const original = this.nodeText;\n    const ident = original.replace(this.symbols.PENDING_GATE, '');\n    const lookup = this.pendingGates[ident];\n\n    if (!lookup) {\n      throw Error('no pending gate=\"' + original + '\" pgates=' +\n        JSON.stringify(Object.keys(this.pendingGates)));\n    }\n\n    const stillUnresolved = lookup.operands.some((o) => {\n      let { result, resolved } = this.checkContext(o);\n      if (typeof result === 'function') {\n        // while {} ?\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n      }\n      return typeof result === 'undefined' || !resolved;\n    });\n\n    if (stillUnresolved) return original; // still deferred\n\n    const result = this.choice(lookup.deferredContext); // execute the gate\n    return result;\n  }\n\n  else(ctx) {\n    // this.print('else', this.nodeText);\n    return this.visit(ctx.expr).trim();\n  }\n\n  choice(ctx, opts) {\n    const $ = this.symbols;\n    let rawGate, gateResult;\n    const original = this.nodeText;\n    let info = original;\n    const choiceKey = this.RiScript._stringHash(original + ' #' + this.choiceId(ctx));\n\n    if (!this.isNoRepeat && this.hasNoRepeat(ctx.TF)) {\n      throw Error('noRepeat() not allowed on choice (use a $variable instead): ' + original);\n    }\n\n    let decision = 'accept';\n    if (opts?.forceReject) {\n      decision = 'reject';\n    } else {\n      if (ctx.gate) {\n        // do we have a gate\n        rawGate = ctx.gate[0].children.Gate[0].image;\n        gateResult = this.visit(ctx.gate);\n        decision = gateResult.decision;\n        info += `\\n  [gate] ${rawGate} -> ${decision !== 'defer'\n          ? decision.toUpperCase()\n          : `DEFER ${$.PENDING_GATE}${choiceKey}`\n          }  ${this.lookupsToString()}`;\n      }\n\n      if (gateResult) {\n        if (gateResult.decision === 'defer') {\n          this.pendingGates[choiceKey] = {\n            deferredContext: ctx,\n            operands: gateResult.operands\n          };\n          return `${$.PENDING_GATE}${choiceKey}`; // gate defers\n        }\n      }\n    }\n\n    if (decision === 'reject' && !('reject' in ctx)) {\n      return ''; // rejected without reject expr, return ''\n    }\n\n    const orExpr = ctx[decision]?.[0]?.children?.or_expr?.[0]; // yuck\n    const options = this.parseOptions(orExpr); // get options\n    if (!options) throw Error('No options in choice: ' + original);\n\n    let value = null;\n    const excluded = [];\n    let restored = false;\n    while (value === null) {\n      value = this.choose(options, excluded).value;\n\n      // if we still have script, defer until its resolved\n      if (this.scripting.isParseable(value)) {\n        if (ctx.TF) value = this.restoreTransforms(value, ctx.TF);\n        restored = true;\n        break;\n      }\n\n      // apply any remaining transforms\n      if (ctx.TF) value = this.applyTransforms(value, ctx.TF);\n\n      // we have 'norepeat' but value was already used, try again\n      if (this.isNoRepeat && value === this.choices[choiceKey]) {\n        this.print('choice.reject', value + ' [norepeat]');\n        excluded.push(value);\n        value = null;\n        continue;\n      }\n    }\n\n    if (!restored) this.choices[choiceKey] = value; // put in choice cache\n\n    return value;\n  }\n\n  // Helpers ================================================\n\n  hasNoRepeat(tfs) {\n    const transforms = this.RiScript._transformNames(tfs);\n    if (transforms.length) {\n      return transforms.includes('nr') || transforms.includes('norepeat');\n    }\n    return false;\n  }\n\n  checkContext(ident) {\n    let isStatic = false;\n    let isUser = false;\n    let result;\n\n    if (ident.length === 0) {\n      return { result: '', resolved: true, isStatic, isUser };\n    }\n\n    // check for dynamic symbol: $var\n    result = this.dynamics[ident];\n    if (typeof result === 'undefined') {\n      // no dynamic\n\n      // check for static symbol: #var\n      result = this.statics[ident];\n      if (typeof result !== 'undefined') {\n        isStatic = true; // found static\n      }\n    }\n\n    if (typeof result === 'undefined') {\n      // no static\n      // check for user-defined symbol: context[var]\n      result = this.context[ident];\n      if (typeof result !== 'undefined') {\n        isUser = true; // found user symbol\n      } else {\n        // check for user-defined dynamic? context[$var]\n        result = this.context[this.symbols.DYNAMIC + ident];\n        if (typeof result !== 'undefined') {\n          // no static\n          // note: treat as normal dynamic, isUser = false\n        }\n      }\n    }\n\n    // do we have more script to deal with ?\n    const resolved = !this.scripting.isParseable(result);\n\n    return { result, isStatic, isUser, resolved }; // TODO: replace with 'type'\n  }\n\n  inlineAssignment(ident, tfs, result) {\n    const $ = this.symbols;\n    const lhs = $.STATIC + ident;\n    const rhs = this.restoreTransforms(result, tfs);\n    result = $.OPEN_CHOICE + (lhs + '=' + rhs) + $.CLOSE_CHOICE;\n    return result;\n  }\n\n  choiceId(ctx) {\n    if (!ctx.OC || !ctx.OC.length) throw Error('invalid choice');\n    return ctx.OC[0].startOffset + '.' + ctx.OC[0].endOffset;\n  }\n\n  parseOptions(ctx) {\n    const options = [];\n    if (ctx && ctx?.children?.wexpr) {\n      const wexprs = ctx.children.wexpr;\n      for (let i = 0; i < wexprs.length; i++) {\n        const wexpr = wexprs[i];\n        const expr = wexpr.children.expr;\n        if (expr && expr.length != 1) { throw Error('invalid choice-expr: ' + expr.length); }\n\n        const weight = wexpr.children.Weight;\n        if (weight) {\n          if (weight.length != 1) { throw Error('invalid weight: ' + weight.length); }\n          let mult = 1;\n          try {\n            mult = parseInt(\n              this.symbols.CLOSE_WEIGHT.length\n                ? weight[0].image.trim().slice(1, -1)\n                : weight[0].image.trim().slice(1)\n            );\n          } catch (e) {\n            console.log('EX: ' + mult);\n          }\n          Array.from({ length: mult }, () => options.push(expr));\n        } else {\n          options.push(expr || '');\n        }\n      }\n    }\n    return options;\n  }\n\n  chooseUnique(options, choiceKey) {\n    // not used\n\n    const isUnique = false;\n    while (options.length && !isUnique) {\n      const { index, value } = this.choose(options);\n      if (value !== this.choices[choiceKey]) return value;\n      // console.log(`Skipping ${index}: '${value}'`);\n      options.splice(index, 1);\n    }\n    throw Error('No remaining options');\n  }\n\n  choose(options, excludes = []) {\n    if (!options || !options.length) {\n      throw Error('Invalid choice: no options');\n    }\n\n    const valid = options.filter((x) => !excludes.includes(x));\n    if (!valid.length) {\n      throw Error('Invalid choice: no valid options');\n    }\n\n    const index = this.scripting.RiTa.randi(valid.length);\n\n    let value = ''; const selected = valid[index];\n\n    if (typeof selected === 'string') {\n      this.print('choice.text', \"''\");\n    } else {\n      // if (typeof selected === 'object') {\n      this.path = 'choice.' + this.path;\n      value = this.visit(selected); // cstNode\n    }\n\n    if (typeof value === 'string') value = value.trim();\n\n    return { index, value };\n  }\n\n  applyTransforms(value, txs) {\n    if (this.traceTx) { console.log('applyTransforms', this.formatTxs(...arguments)); }\n    for (let i = 0; i < txs.length; i++) {\n      value = this.applyTransform(value, txs[i]);\n    }\n    return value;\n  }\n\n  // value is not yet resolved, so store with transform for later\n  restoreTransforms(value, txs) {\n    if (typeof value === 'string') {\n      const patt = new RegExp(\n        '^' + this.escaped.OPEN_CHOICE + '.*' + this.escaped.CLOSE_CHOICE + '$'\n      );\n      if (!patt.test(value)) {\n        // wrap in choice to preserve\n        value = this.symbols.OPEN_CHOICE + value + this.symbols.CLOSE_CHOICE;\n      }\n      if (txs) {\n        txs.forEach((tx) => (value += tx.image)); // append transform strings\n      }\n      if (this.traceTx) console.log('restoreTransforms:', value);\n    }\n    return value;\n  }\n\n  castValues(obj) {\n    let madeCast = false;\n    Object.entries(obj).forEach(([k, v]) => {\n      const num = parseFloat(v);\n      if (!isNaN(num)) {\n        madeCast = true;\n        obj[k] = num; // update object with casted value\n      }\n    });\n    return madeCast;\n  }\n\n  contextIsResolved(table) {\n    let allResolved = true;\n    Object.entries(table).forEach(([key, val]) => {\n      if (!this.scripting.isParseable(val)) {\n        allResolved = false;\n      }\n    });\n    return allResolved;\n  }\n\n  applyTransform(target, transform) {\n    const image = transform.image;\n    let result;\n    const raw = target + image;\n    const tx = image.substring(1).replace(/\\(\\)$/, '');\n\n    // function in dynamics\n    if (typeof this.dynamics[tx] === 'function') {\n      result = this.dynamics[tx](target);\n    }\n    // function in statics\n    else if (typeof this.statics[tx] === 'function') {\n      result = this.statics[tx](target);\n    }\n    // function in context\n    else if (typeof this.context[tx] === 'function') {\n      result = this.context[tx](target);\n    }\n\n    // function in transforms\n    else if (typeof this.RiScript.transforms[tx] === 'function') {\n      result = this.RiScript.transforms[tx](target);\n    }\n    // member functions (usually on String)\n    else if (typeof target[tx] === 'function') {\n      result = target[tx]();\n    } else {\n      // check for property\n      if (target.hasOwnProperty(tx)) {\n        result = target[tx];\n      } else {\n        if (!this.scripting.RiTa.SILENT && !this.scripting.silent) {\n          console.warn('[WARN] Unresolved transform: ' + raw);\n        }\n\n        /* Replace transform parens so as not to trigger\n           RiScript.isParseable (for example, in v2) 0 */\n        result = raw.replace(/\\(\\)$/, '&lpar;&rpar;');\n      }\n    }\n\n    if (this.trace) { console.log(`${this.tindent()}[transform] ${raw} -> '${result}'`); }\n\n    return result;\n  }\n\n  lookupsToString() {\n    const dyns = {};\n    const stats = {};\n    Object.entries(this.dynamics || {}).forEach(\n      ([k, v]) => (dyns[`$${k} `] = v)\n    );\n    Object.entries(this.statics || {}).forEach(\n      ([k, v]) => (stats[`#${k} `] = v)\n    );\n    return JSON.stringify({ ...this.context, ...stats, ...dyns }, (k, v) =>\n      typeof v === 'function' ? '<f*:pending>' : v\n    ).replace(/\"/g, '');\n  }\n\n  formatTxs(value, txs) {\n    return value + txs.map((tx) => tx.image.replace(/()/, '') + '()').join('');\n  }\n\n  print(s, ...args) {\n    if (this.trace) {\n      if (this.path && s !== 'script') {\n        s = this.path.replace(/\\.$/, '');\n      }\n      console.log(++this.order, `[${s}]`, ...args);\n      this.path = '';\n    }\n  }\n\n  tindent() {\n    return ' '.repeat((this.order + '').length + 1);\n  }\n}\n\nexport { RiScriptVisitor };\n\n// console.log('&#33; -> '+decode('&#33;'));\n// console.log('&amp; -> '+decode('&amp;'));\n","import { RiScript } from './riscript.js'\n\nclass RiGrammar {\n\n  constructor(rules = {}, context = {}) {\n    if (typeof rules !== 'object') {\n      throw Error('RiGrammar: expecting object, found ' + typeof rules);\n    }\n\n    this.scripting = new RiScript();\n    this.context = context;\n    this.setRules(rules);\n  }\n\n  static expand(rules, context, opts) {\n    return new RiGrammar(rules, context).expand(opts);\n  }\n\n  addTransform() {\n    return RiScript.addTransform(...arguments);\n  }\n  removeTransform() {\n    return RiScript.removeTransform(...arguments);\n  }\n  getTransforms() {\n    return RiScript.transforms;\n  }\n\n  equals(rg) {\n    return rg.toJSON() === this.toJSON();\n  }\n\n  expand(opts = {}) {\n    if ('context' in opts) {\n      throw Error('pass context to RiScript.grammar() or new RiGrammar() instead');\n    }\n\n    // TODO: clone opts here ?\n    opts.visitor = opts.visitor || new RiScript.Visitor(this.scripting);\n    opts.visitor.context = this.context || {};\n    opts.input = this._toScript(opts);\n    // opts.noAddedSilence = true;\n\n    return this.scripting._evaluate(opts);\n  }\n\n  addRule(name, def) {\n    this._validateRule(name, def);\n    this.rules[name] = def;\n  }\n\n  setRules(rules) {\n    if (typeof rules === 'undefined') throw Error('undefined rules');\n    this.rules = {};\n    let incoming = typeof rules === 'string' ? parseJSON(rules) : rules;\n    let self = this;\n    Object.entries(incoming).forEach((e) => self.addRule(...e));\n  }\n\n  removeRule(name) {\n    if (name in this.rules) {\n      delete this.rules[name];\n    }\n  }\n\n  toJSON() {\n    return JSON.stringify(this.rules, ...arguments);\n  }\n\n  toString(opts = {}) {\n    let replacer = opts.replacer || 0;\n    let space = opts.space || 2;\n    let lb = opts?.linebreak;\n    let res = this.toJSON(replacer, space);\n    if (lb) res = res.replace(/\\n/g, lb);\n    return res;\n  }\n\n  static fromJSON(str, opts) {\n    return new RiGrammar(JSON.parse(str), opts);\n  }\n\n  /* \n    Convert grammar to inline rules;\n    rules are dynamic, unless otherwise specified with leading #\n  */\n  _toScript(opts) {\n    let script = '',\n      start = opts.start || 'start';\n    let { Symbols } = this.scripting;\n\n    if (start.startsWith(Symbols.DYNAMIC)) {\n      start = start.substring(Symbols.DYNAMIC.length);\n    }\n\n    if (start.startsWith(Symbols.STATIC)) {\n      start = start.substring(Symbols.STATIC.length);\n    }\n\n    if (!(start in this.rules || Symbols.STATIC + start in this.rules)) {\n      throw Error('Rule: \"' + start + '\" not found in grammar');\n    }\n\n    Object.entries(this.rules).forEach(([name, rule], i) => {\n      while (name.startsWith(Symbols.DYNAMIC)) {\n        name = name.substring(1);\n      }\n      if (!name.startsWith(Symbols.STATIC)) {\n        name = Symbols.DYNAMIC + name;\n      }\n      // console.log(i,name);\n      if (!this.scripting.ChoiceWrapRE.test(rule)) {\n        // let orig = rule;\n        rule = Symbols.OPEN_CHOICE + rule + Symbols.CLOSE_CHOICE;\n        // console.log('WRAPPING: ' + orig + '->' + rule);\n      }\n      script += `${name}=${rule}\\n`;\n    });\n\n    if (opts.trace) console.log('Grammar:\\n' + script.replace(/^\\$/gm, '  $'));\n\n    script += `${Symbols.DYNAMIC}${start}`;\n    return script;\n  }\n\n  _validateRule(name, def) {\n    if (typeof name !== 'string' || name.length === 0) {\n      throw Error('expected [string] name');\n    }\n\n    if (typeof def === 'undefined') {\n      throw Error('undefined rule def: ' + name);\n    }\n    let { Symbols } = this.scripting;\n\n    if (name.startsWith(Symbols.DYNAMIC)) {\n      name = name.substring(Symbols.DYNAMIC.length);\n      throw Error(\n        'Grammar rules are dynamic by default;' +\n          \" if you need a static rule, use '\" +\n          Symbols.STATIC +\n          name +\n          \"', otherwise just use '\" +\n          name +\n          \"'.\"\n      );\n    }\n  }\n}\n\nfunction parseJSON(json) {\n  if (typeof json === 'string') {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      throw Error(\n        'RiGrammar appears to be invalid JSON,' +\n          ' please check it at http://jsonlint.com/\\n' +\n          json\n      );\n    }\n  }\n}\n\nexport { RiGrammar };\n","import { RiScript } from './riscript.js';\nimport { RiGrammar } from './grammar.js';\nimport { RiScriptVisitor } from './visitor.js';\n\nRiScript.Grammar = RiGrammar;\nRiScript.Visitor = RiScriptVisitor;\n\nexport default RiScript\n"],"mappings":"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","names":["result","text"]}